* get Rsamtools and Rhtslib (provisionally, from github.com/nhayden)
Rhtslib:
git clone --recursive https://github.com/nhayden/Rhtslib.git

Rsamtools:
git clone --recursive -b htslib https://github.com/nhayden/Rsamtools.git

* Rsamtools => Rhtslib + Rsamtools
samtools used to be a monolithic distribution that had the libbam,
libbcf, libtabix (as well as fa file) libraries.

Now the samtools environment has been redesigned. "Common"
functionality (the line is rather blurry) is in a separate library,
htslib, with applications (samtools, tabix, bcf) that use the
library. More data-/file-type-independent abstractions have been
introduced so less code is spent explicitly testing for file type,
etc.

* Why is the build system s'damn complicated?
Windows. I think htslib started with the intention of nominally
supporting Windows, but the rapid development of the library has
outpaced the willingnes to support and test Windows. The htslib
library itself as well as the build system is written in a
Unix-centric way.

Enter Gnulib.

** Autotools: autoconf, automake, Gnulib (not actually an autotool)
- diagram of autotools interaction:
  https://devmanual.gentoo.org/general-concepts/autotools/

*** autoconf:
- writes the configure script that probes the host environment by
  trying to compile (test for functionality and compiler
  characteristics) and link (test for library support) miniature
  programs
- abstraction: you don't have to compile a list by hand ahead of time
  which of your supported environments support various functionality
  (often system calls), etc.
- typically leverage preprocessor macros to say "use this function if
  available, or use this system call if not":
  - #ifdef HAVE_SYSCALL_ABC
    syscall_abc();
    #else
    syscall_xyz();
    #endif

*** automake:
- derives make rules for you, figures out what tools on the host
  system to use to get there
- abstraction: write metarules, i.e., "this is what I have to start
  from, this is what I want as my end product". For example, you don't
  ever have to mention .o (object) files because these are
  intermediate products; similar to how autoconf writes the configure
  scripts for you based on what you want to test

*** gnulib: the imagination tool
- makes it so you can pretend you're on a reasonable platform, instead
  of fighting with the OS.
- the #ifdef syscall_abc #else syscall_xyz #endif gets replaced with

  syscall_abc

  that, if on an OS with syscall_xyz but not syscall_abc, wraps
  syscall_xyz and Does the Right Thing behind the scenes.

- or it makes possible things that would be impossible without a huge
  development burden--writing stand-in libraries and shims, etc. For a
  standalone example, it turned out the new samtools that depends on
  htslib requires the Unix-like libregex and regex.h; the top solution
  to get around libregex's absence on Windows? A libregex built using
  Gnulib!

But in order to be so slick, gnulib relies on autotools to figure out
the appropriate wrapping. Hence, the build system is damn complicated.

* What's in Rhtslib
The Rhtslib R package has a minimal R package wrapper (basically just
a vignette for linking against it and a configure script that changes
to the htslib dir and runs make there) around a git submodule that is
a fork of the htslib repository. Almost all of the upstream htslib
repository is included (for example, the unit test programs and perl
script with associated test files are included). You can cd into the
htslib subdirectory and muck around as if it were a standalone
repos. Running the unit tests works via `make check`.

- Copies of intermediate files generated by autotools in Rhtslib/tools

** How it's different from upstream
- adapted the build system to use autotools. This was the hardest
  part, there are significant differences, and the lingering
  pain-point in continued integration with upstream
- added Gnulib: http://wiki.opencsw.org/adding-gnulib; added `#include
  "config.h"`(?) to almost all header files(?)
- a few in-code fixes to get things to behave right on Windows, mostly
  line-ending behavior for binary vs. plain text file types.

* Examples of linking against Rhtslib
- link2Rhtslib, to confirm correct linking github.com/nhayden/link2Rhtslib
- real packages: deepSNV or bamsignals, both good quality

* What's in Rsamtools

** oddities
- there are duplicate source / header file names if you consider the
  union of the file names between htslib and samtools.

* How to add to Gnulib


